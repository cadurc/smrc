{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\n\n\n\nThis note introduces my experiences of using the Raspberry Pi to automate a model railway.\n\n\nTwo aspects are covered:\n\n\n\n\nSending commands to a DCC controller\n\n\nDetecting a train\u2019s position\n\n\n\n\n\n\nSchematic showing the Pi's USB and I2C interfaces\n\n\nSending commands to a DCC controller\n\n\nThe RPi is connected to a Hornby Elite DCC controller by a USB cable. A python program sends XPressNet commands to the controller using the python serial package (python-serial). \n\n\nThe XPressNet protocol (developed by Lenz) allows DCC control devices such as hand-held controllers to be connected to the command station . Such connections are high-speed RS-485 links. Lenz and probably others make devices that allow PCs to be connected to the XPressNet bus via a slow speed (e.g. 9600 or 19200 Baud) serial connection. The Hornby Elite has this slow speed interface built in allowing it to be  connected directly to a PC\u2019s (or RPi\u2019s) USB port. For further information about XPressNet including the full specification see the \nLenz website\n\n\nI\u2019m only using commands that control the trains throttle, functions (e.g.sound) and accessories (e.g signals). I don\u2019t know how fully the protocol is implemented by the Elite. There appear to be discrepancies between the documented responses and what I get back from Elite after a command has been sent. Currently, I only look for a x\u201905\u2018. If I get it, I assume the command has been executed successfully, if I don\u2019t, I resend the command.\n\n\nOne problem I had, was getting Linux to correctly recognise the Elite when it was connected to the RPi. It appears that Hornby incorrectly uses product and device ids in their firmware. This results in the wrong drivers being associated with the Elite. This problem can be resolved by creating a file called : \n\n\n/etc/udev/rules.d/10-elite.rules\n\n\n\n\ncontaining the following command (all one line):\n\n\nATTR{idVendor}==\n04d8\n, ATTR{idProduct}==\n000a\n, RUN+=\n/sbin/modprobe -q ftdi_sio vendor=0x04d8 product=0x000a\n\n\n\n\n\nYou should see a message similar to the following when Linux is restarted:\n\n\n[    7.319030] usb 1-1.3.1: FTDI USB Serial Device converter now attached to ttyUSB1\n[    7.356074] usbcore: registered new interface driver ftdi_sio\n\n\n\n\nThe application program running on the RPi should now be able to communicate with the Elite using the file id ttyUSB1.\n\n\nBefore python can communicate with the serial port you need to install the python serial package e.g. :\n\n\nsudo apt-get install python-serial\n\n\n\n\nExamples\n\n\nThe following snippets are examples or sending commands to the controller from a python program.\n\n\nTo use the python serial interface import the serial package:\n\n\nimport serial\n\n\n\n\nThe following will open the serial port ttyUSB1 with a speed of 9600 Baud, no parity and one stop bit:\n\n\nser = serial.Serial('/dev/ttyUSB1',9600)\n\n\n\n\nTo send a command, use the write method (\u2018message\u2018 could be a string, but I\u2019ve found easier to build a command as a bytearray):\n\n\nser.write(message)\n\n\n\n\nTo close the serial port, call the close method:\n\n\nser.close()\n\n\n\n\nThe following is an example of sending a command and waiting for a response. If a x\u201905\u2019 is not received, the command will be resent up to a maximum of 5 times:\n\n\ndef send(message):\n    ok = False\n    trys = 1\n    while (not ok and trys \n 5) :\n        ser.write(message)\n        print 'trys = %d send:' % (trys) , \n        for byte in message:print(hex(byte)) ,\n        time.sleep(.1)\n        print ' receive: ',     \n        while ser.inWaiting() \n 0 :\n            enq = ser.read()\n            print enq.encode('hex') ,  \n            if enq == '05'.decode('hex') : \n                ok = True\n        print \n        trys += 1\n\n\n\n\nThe XPressNet protocol states that the last byte of a command is a \u2018Error detection byte\u2019. It is formed using an X-Or linkage of the proceeding bytes of the command.  The following function will determine the error detection byte:\n\n\ndef parity(message):\n    edb = 0\n    for byte in message:\n        edb ^= byte\n    message.append(edb)\n\n\n\n\nThe following example shows how a function could be coded to implement the XPressNet throttle command:\n\n\ndef setThrottle(address,direction,speed):\n    message = bytearray('E400000000'.decode('hex'))\n    message[1] = 0x13\n    message[3] = address\n    message[4] = speed\n    if direction  == 'f' : message[4] |= int(b'10000000',2)\n    elif direction =='b' : message[4] \n= int(b'01111111',2)\n    parity(message) \n    send  (message) \n\n\n\n\nDetecting a train\u2019s position\n\n\nFor railway automation to be effective, some sort of positional feedback is required. There are a number of techniques for achieving this, ranging from sophisticated RFID readers that can read information stored on tags fitted to the train to simple mechanical switches such as reed relays activated by magnets fitted under the train.\n\n\nThe approach adopted with this project, is the use of hall-effect switches fitted to the track and a magnet fitted to the underside of each train. It has the following advantages:\n\n\n\n\nIt is relatively inexpensive, compared with the RFID approach.\n\n\nMultiple sensors (a maximum of 128) could be connected to the RPi.\n\n\nIt is reasonably reliable compared with mechanical switches.\n\n\nThe sensors can be easily moved around the track when developing a layout.\n\n\n\n\nThis approach does, however, lack the ability for a computer to distinguish between different trains. A complex layout with a number of trains concurrently running will struggle to achieve full automation, however, even with a reasonable size layout, it should be possible to manage a degree of automation by building algorithms into the automation program that will deduce which train has triggered the sensor by the sequence of sensors activated. \n\n\nThe positional feedback system comprises of two components:\n\n\n\n\nThe Hall-effect switch. \n\n\nThe Hall-effect switch interface.\n\n\n\n\nThe Hall-effect switch\n\n\nThe hall-effect switch is a small device that fits on the railway track. The A1121LUA -T is just the right size to fit between the sleepers of a Hornby track.\n\n\n\n\nThe hall-effect switch fitted between the sleepers\n\n\nThe flat side of the device should be facing upwards towards the underside of the train. Care must be taken to ensure the three leads that protrude from the device do not touch each other or the metal rail.\n\n\nFor detailed information of the device see the \ndevice data sheet\n and \nthe applications guide\n\n\nThe switch is activated when the south-pole of a magnet passes over the hall-effect device.\n\n\n\n\nPicture showing a magnet located beneath the train secured with Blutack\n\n\nThe Hall-effect switch interface\n\n\nThe output of the switch is capable of directly driving CMOS or TTL logic. In it\u2019s normal state the output is HIGH. When the south-pole of the magnet passes overhead, the output pin is driven LOW.\n\n\nThe Hall-effect switch output is connected to a 16-Bit I/O Expander (MCP23017).\n\n\n\n\nCircuit diagram of the Hall-effect sensor interface\n\n\nFor further information regarding the MCP23017 see the \nMicrochip Data sheet\n\n\nIt is assumed that the automation program will enable the internal pull-up resistors on the inputs to the MCP23017. This eliminates the need for external resistors between input pins and the positive rail (for example pin 21 and +5V).\n\n\nThe MCP23017 has 2 groups of I/O ports:\n\n\n\n\nGPA0 - GPA7  (pins 21 - 28)\n\n\nGPB0 - GPB7 (pins 1 - 8)\n\n\n\n\nThe circuit diagram shows only 4 sensors connected GPA0 - GPA3. It is possible to connect a further 4 sensors to GPA4 - GPA7 (pins 24 - 28).\n\n\nIn addition, a further 8 sensors could be connected to GPB0 - GPB7. The circuit diagram shows GPB0 - GPB3 (pins 1 - 4) being used as outputs to drive LEDs used as indicators driven by the automation program. R1 - R4 are resistors of suitable value to act as limiting resistors to protect the LEDs.  The project is currently using 330 ohm resistors.\n\n\nThe circuit diagram also shows an LED connected to the interrupt output for I/O port A. \n\n\nThe MCP23017 is connected to the RPi via it\u2019s I2C interface.\n\n\nFor further information about I2C, see \nthe I2C website\n\n\nThe IC2 bus consists of 2 data connections to the RPi\n\n\n\n\nSCL (pin 12 on the MCP23017) - Serial clock input - driven by the RPi\n\n\nSDA (pin 13 on the MCP23017) - Serial data I/O\n\n\n\n\nIn the current version of the project the 5V supply of the RPi is used to power the sensor interface and the sensors. Care must be taken that this supply is not over-loaded. If the 5V supply of the RPi drops to below 4.9V it is advisable to use an independent power supply for the interface and sensors.\n\n\nThe interface is connected to the RPI through its GPIO port, 26 pin male plug fitted on the edge of the RPi. Refer to RPi documentation for the correct pin layout of this plug.\n\n\n\n\npin 2 - +5V\n\n\npin 3 - I2C SDA\n\n\npin 5 - I2C SCL\n\n\npin 6 - Ground\n\n\n\n\nUp to 8 MCP23017 devices could be connected to the RPi\u2019s I2C bus. The address of each device is determined by the 3 address select pins (pins 15, 16, and 17). In the current project only one device is on the bus, so all address pins are taken to LOW.   \n\n\nYou will need to enable I2C on the RPi. SK Pang Electronics have  a very good step by step \nguide to I2C installation\n\n\nExamples\n\n\nThe following snippets are examples of managing the sensor interface from a python program.\n\n\nTo start using the I2c interface you must import smbus:\n\n\nimport smbus\n\n\n\n\nInstantiate an instance of smbus:\n\n\nbus = smbus.SMBus(0)\n\n\n\n\nDefine the address of the I/O expander. If all 3 address pins are LOW then the device address is 0x20\"\n\n\naddress = 0x20 # I2C address of MCP23017\n\n\n\n\nDefine constants for the registers in the MCP23017. For information about the registers and their purpose see the \nMicrochip Data sheet\n\n\nIODIRA =  0x00 \nIODIRB =  0x01\nGPINTENA = 0X04\nGPINTENB = 0x05\nGPPUA  =  0x0c\nGPPUB  =  0x0d\nINTCAPA=  0x10\nINTCAPB=  0x11\nGPIOA  =  0x12\nGPIOB  =  0x13\n\n\n\n\nInitialize the I/O ports. In this example the sensors are connected to Port A, therefore all pins are set as inputs. LEDs are connected to port B, so they are set as outputs: \n\n\nbus.write_byte_data(address,IODIRA,0xff) # Set all of port A to inputs\nbus.write_byte_data(address,IODIRB,0x00) # Set all of port B to outputs\n\n\n\n\nThe MCP23017 has internal pull-up resistors that remove the necessity to use external resistors between the sensor output and the positive rail (+5V):\n\n\nbus.write_byte_data(address,GPPUA,0xff)  # Enable pull-up resistors on port A\n\n\n\n\nIf the interrupt mechanism on the MCP23017 is enabled, then once a sensor is activated, the state of the associated I/O register is stored in the interrupt capture register(INTCAP). This state will be \u2018frozen\u2018 until the MCP23017 generates another interrupt, i.e. a sensor is activated: \n\n\nbus.write_byte_data(address,GPINTENA,0xff) #Enable interrupts on port A\n\n\n\n\nRead the interrupt capture register:\n\n\nx=bus.read_byte_data(address,INTCAPA)\n\n\n\n\nThe following example  assumes 4 sensors are on a piece of track. The function will print the name of the last sensor that was activated:\n\n\ndef read_INTCAPA():\n    x=bus.read_byte_data(address,INTCAPA)\n    if (not x \n 0x08) : print 'Sensor 4'\n    if (not x \n 0x04) : print 'Sensor 3'\n    if (not x \n 0x02) : print 'Sensor 2'\n    if (not x \n 0x01) : print 'Sensor 1\u2019\n\n\n\n\nPython Scripts\n\n\nThe following python scripts demonstrate controlling and detecting a train.\n\n\n\n\nhornby.py - an api for controlling a Hornby Elite DCC controller\n\n\nheSensor.py - a hall-effect sensor interface\n\n\nsmra1.py - demonstrates the use of hornby.py and heSensor.py for automating a simple railway layout\n\n\nsmrc1.py - a web server that allows a browser to control model trains using hornby.py", 
            "title": "Home"
        }, 
        {
            "location": "/#overview", 
            "text": "This note introduces my experiences of using the Raspberry Pi to automate a model railway.  Two aspects are covered:   Sending commands to a DCC controller  Detecting a train\u2019s position    Schematic showing the Pi's USB and I2C interfaces", 
            "title": "Overview"
        }, 
        {
            "location": "/#sending-commands-to-a-dcc-controller", 
            "text": "The RPi is connected to a Hornby Elite DCC controller by a USB cable. A python program sends XPressNet commands to the controller using the python serial package (python-serial).   The XPressNet protocol (developed by Lenz) allows DCC control devices such as hand-held controllers to be connected to the command station . Such connections are high-speed RS-485 links. Lenz and probably others make devices that allow PCs to be connected to the XPressNet bus via a slow speed (e.g. 9600 or 19200 Baud) serial connection. The Hornby Elite has this slow speed interface built in allowing it to be  connected directly to a PC\u2019s (or RPi\u2019s) USB port. For further information about XPressNet including the full specification see the  Lenz website  I\u2019m only using commands that control the trains throttle, functions (e.g.sound) and accessories (e.g signals). I don\u2019t know how fully the protocol is implemented by the Elite. There appear to be discrepancies between the documented responses and what I get back from Elite after a command has been sent. Currently, I only look for a x\u201905\u2018. If I get it, I assume the command has been executed successfully, if I don\u2019t, I resend the command.  One problem I had, was getting Linux to correctly recognise the Elite when it was connected to the RPi. It appears that Hornby incorrectly uses product and device ids in their firmware. This results in the wrong drivers being associated with the Elite. This problem can be resolved by creating a file called :   /etc/udev/rules.d/10-elite.rules  containing the following command (all one line):  ATTR{idVendor}== 04d8 , ATTR{idProduct}== 000a , RUN+= /sbin/modprobe -q ftdi_sio vendor=0x04d8 product=0x000a   You should see a message similar to the following when Linux is restarted:  [    7.319030] usb 1-1.3.1: FTDI USB Serial Device converter now attached to ttyUSB1\n[    7.356074] usbcore: registered new interface driver ftdi_sio  The application program running on the RPi should now be able to communicate with the Elite using the file id ttyUSB1.  Before python can communicate with the serial port you need to install the python serial package e.g. :  sudo apt-get install python-serial", 
            "title": "Sending commands to a DCC controller"
        }, 
        {
            "location": "/#examples", 
            "text": "The following snippets are examples or sending commands to the controller from a python program.  To use the python serial interface import the serial package:  import serial  The following will open the serial port ttyUSB1 with a speed of 9600 Baud, no parity and one stop bit:  ser = serial.Serial('/dev/ttyUSB1',9600)  To send a command, use the write method (\u2018message\u2018 could be a string, but I\u2019ve found easier to build a command as a bytearray):  ser.write(message)  To close the serial port, call the close method:  ser.close()  The following is an example of sending a command and waiting for a response. If a x\u201905\u2019 is not received, the command will be resent up to a maximum of 5 times:  def send(message):\n    ok = False\n    trys = 1\n    while (not ok and trys   5) :\n        ser.write(message)\n        print 'trys = %d send:' % (trys) , \n        for byte in message:print(hex(byte)) ,\n        time.sleep(.1)\n        print ' receive: ',     \n        while ser.inWaiting()   0 :\n            enq = ser.read()\n            print enq.encode('hex') ,  \n            if enq == '05'.decode('hex') : \n                ok = True\n        print \n        trys += 1  The XPressNet protocol states that the last byte of a command is a \u2018Error detection byte\u2019. It is formed using an X-Or linkage of the proceeding bytes of the command.  The following function will determine the error detection byte:  def parity(message):\n    edb = 0\n    for byte in message:\n        edb ^= byte\n    message.append(edb)  The following example shows how a function could be coded to implement the XPressNet throttle command:  def setThrottle(address,direction,speed):\n    message = bytearray('E400000000'.decode('hex'))\n    message[1] = 0x13\n    message[3] = address\n    message[4] = speed\n    if direction  == 'f' : message[4] |= int(b'10000000',2)\n    elif direction =='b' : message[4]  = int(b'01111111',2)\n    parity(message) \n    send  (message)", 
            "title": "Examples"
        }, 
        {
            "location": "/#detecting-a-trains-position", 
            "text": "For railway automation to be effective, some sort of positional feedback is required. There are a number of techniques for achieving this, ranging from sophisticated RFID readers that can read information stored on tags fitted to the train to simple mechanical switches such as reed relays activated by magnets fitted under the train.  The approach adopted with this project, is the use of hall-effect switches fitted to the track and a magnet fitted to the underside of each train. It has the following advantages:   It is relatively inexpensive, compared with the RFID approach.  Multiple sensors (a maximum of 128) could be connected to the RPi.  It is reasonably reliable compared with mechanical switches.  The sensors can be easily moved around the track when developing a layout.   This approach does, however, lack the ability for a computer to distinguish between different trains. A complex layout with a number of trains concurrently running will struggle to achieve full automation, however, even with a reasonable size layout, it should be possible to manage a degree of automation by building algorithms into the automation program that will deduce which train has triggered the sensor by the sequence of sensors activated.   The positional feedback system comprises of two components:   The Hall-effect switch.   The Hall-effect switch interface.", 
            "title": "Detecting a train\u2019s position"
        }, 
        {
            "location": "/#the-hall-effect-switch", 
            "text": "The hall-effect switch is a small device that fits on the railway track. The A1121LUA -T is just the right size to fit between the sleepers of a Hornby track.   The hall-effect switch fitted between the sleepers  The flat side of the device should be facing upwards towards the underside of the train. Care must be taken to ensure the three leads that protrude from the device do not touch each other or the metal rail.  For detailed information of the device see the  device data sheet  and  the applications guide  The switch is activated when the south-pole of a magnet passes over the hall-effect device.   Picture showing a magnet located beneath the train secured with Blutack", 
            "title": "The Hall-effect switch"
        }, 
        {
            "location": "/#the-hall-effect-switch-interface", 
            "text": "The output of the switch is capable of directly driving CMOS or TTL logic. In it\u2019s normal state the output is HIGH. When the south-pole of the magnet passes overhead, the output pin is driven LOW.  The Hall-effect switch output is connected to a 16-Bit I/O Expander (MCP23017).   Circuit diagram of the Hall-effect sensor interface  For further information regarding the MCP23017 see the  Microchip Data sheet  It is assumed that the automation program will enable the internal pull-up resistors on the inputs to the MCP23017. This eliminates the need for external resistors between input pins and the positive rail (for example pin 21 and +5V).  The MCP23017 has 2 groups of I/O ports:   GPA0 - GPA7  (pins 21 - 28)  GPB0 - GPB7 (pins 1 - 8)   The circuit diagram shows only 4 sensors connected GPA0 - GPA3. It is possible to connect a further 4 sensors to GPA4 - GPA7 (pins 24 - 28).  In addition, a further 8 sensors could be connected to GPB0 - GPB7. The circuit diagram shows GPB0 - GPB3 (pins 1 - 4) being used as outputs to drive LEDs used as indicators driven by the automation program. R1 - R4 are resistors of suitable value to act as limiting resistors to protect the LEDs.  The project is currently using 330 ohm resistors.  The circuit diagram also shows an LED connected to the interrupt output for I/O port A.   The MCP23017 is connected to the RPi via it\u2019s I2C interface.  For further information about I2C, see  the I2C website  The IC2 bus consists of 2 data connections to the RPi   SCL (pin 12 on the MCP23017) - Serial clock input - driven by the RPi  SDA (pin 13 on the MCP23017) - Serial data I/O   In the current version of the project the 5V supply of the RPi is used to power the sensor interface and the sensors. Care must be taken that this supply is not over-loaded. If the 5V supply of the RPi drops to below 4.9V it is advisable to use an independent power supply for the interface and sensors.  The interface is connected to the RPI through its GPIO port, 26 pin male plug fitted on the edge of the RPi. Refer to RPi documentation for the correct pin layout of this plug.   pin 2 - +5V  pin 3 - I2C SDA  pin 5 - I2C SCL  pin 6 - Ground   Up to 8 MCP23017 devices could be connected to the RPi\u2019s I2C bus. The address of each device is determined by the 3 address select pins (pins 15, 16, and 17). In the current project only one device is on the bus, so all address pins are taken to LOW.     You will need to enable I2C on the RPi. SK Pang Electronics have  a very good step by step  guide to I2C installation", 
            "title": "The Hall-effect switch interface"
        }, 
        {
            "location": "/#examples_1", 
            "text": "The following snippets are examples of managing the sensor interface from a python program.  To start using the I2c interface you must import smbus:  import smbus  Instantiate an instance of smbus:  bus = smbus.SMBus(0)  Define the address of the I/O expander. If all 3 address pins are LOW then the device address is 0x20\"  address = 0x20 # I2C address of MCP23017  Define constants for the registers in the MCP23017. For information about the registers and their purpose see the  Microchip Data sheet  IODIRA =  0x00 \nIODIRB =  0x01\nGPINTENA = 0X04\nGPINTENB = 0x05\nGPPUA  =  0x0c\nGPPUB  =  0x0d\nINTCAPA=  0x10\nINTCAPB=  0x11\nGPIOA  =  0x12\nGPIOB  =  0x13  Initialize the I/O ports. In this example the sensors are connected to Port A, therefore all pins are set as inputs. LEDs are connected to port B, so they are set as outputs:   bus.write_byte_data(address,IODIRA,0xff) # Set all of port A to inputs\nbus.write_byte_data(address,IODIRB,0x00) # Set all of port B to outputs  The MCP23017 has internal pull-up resistors that remove the necessity to use external resistors between the sensor output and the positive rail (+5V):  bus.write_byte_data(address,GPPUA,0xff)  # Enable pull-up resistors on port A  If the interrupt mechanism on the MCP23017 is enabled, then once a sensor is activated, the state of the associated I/O register is stored in the interrupt capture register(INTCAP). This state will be \u2018frozen\u2018 until the MCP23017 generates another interrupt, i.e. a sensor is activated:   bus.write_byte_data(address,GPINTENA,0xff) #Enable interrupts on port A  Read the interrupt capture register:  x=bus.read_byte_data(address,INTCAPA)  The following example  assumes 4 sensors are on a piece of track. The function will print the name of the last sensor that was activated:  def read_INTCAPA():\n    x=bus.read_byte_data(address,INTCAPA)\n    if (not x   0x08) : print 'Sensor 4'\n    if (not x   0x04) : print 'Sensor 3'\n    if (not x   0x02) : print 'Sensor 2'\n    if (not x   0x01) : print 'Sensor 1\u2019", 
            "title": "Examples"
        }, 
        {
            "location": "/#python-scripts", 
            "text": "The following python scripts demonstrate controlling and detecting a train.   hornby.py - an api for controlling a Hornby Elite DCC controller  heSensor.py - a hall-effect sensor interface  smra1.py - demonstrates the use of hornby.py and heSensor.py for automating a simple railway layout  smrc1.py - a web server that allows a browser to control model trains using hornby.py", 
            "title": "Python Scripts"
        }
    ]
}